// Generated by CoffeeScript 1.6.1
var QS, Router, URL, stringifyURL,
  __slice = [].slice;

QS = require("querystring");

URL = require("url");

stringifyURL = function(item) {
  var url;
  url = [];
  if (item.hostname) {
    if (item.protocol) {
      url.push("" + item.protocol + "//");
    } else {
      url.push('//');
    }
    url.push(item.hostname);
    if (item.port) {
      url.push(":" + item.port);
    }
  }
  if (item.pathname) {
    url.push(item.pathname);
  } else {
    url.push("/");
  }
  if (item.query) {
    if (item.query === String(item.query)) {
      url.push("?" + item.query);
    } else {
      url.push("?" + (QS.stringify(item.query)));
    }
  }
  if (item.hash) {
    url.push("" + item.hash);
  }
  return url.join('');
};

/*
A URL Router.
*/


module.exports = Router = (function() {
  /*
  Configure the router
  */

  function Router(rules) {
    var rule, _i, _len;
    this.rules = [];
    if (rules != null) {
      for (_i = 0, _len = rules.length; _i < _len; _i++) {
        rule = rules[_i];
        this.add(rule);
      }
    }
  }

  /*
  Dispatches a request for the given URL
  */


  Router.prototype.dispatch = function(url) {
    var creator, handler, options, parse, _i, _len, _ref, _ref1;
    url = this.normalizeUrl(url);
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], parse = _ref1[0], creator = _ref1[1], handler = _ref1[2];
      if ((options = parse(url))) {
        return handler(options);
      }
    }
    return false;
  };

  /*
  Parses a given URL
  */


  Router.prototype.parseUrl = function(url) {
    var creator, handler, options, parse, _i, _len, _ref, _ref1;
    url = this.normalizeUrl(url);
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], parse = _ref1[0], creator = _ref1[1], handler = _ref1[2];
      if ((options = parse(url))) {
        return options;
      }
    }
    return false;
  };

  /*
  Creates a URL based on the given options
  */


  Router.prototype.createUrl = function(options) {
    var creator, handler, parse, url, _i, _len, _ref, _ref1;
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], parse = _ref1[0], creator = _ref1[1], handler = _ref1[2];
      if ((url = creator(options))) {
        return url;
      }
    }
    return false;
  };

  /*
  Normalize a URL
  */


  Router.prototype.normalizeUrl = function(url) {
    if (url === String(url)) {
      url = URL.parse(url);
    }
    if (url.query === String(url.query)) {
      url.query = QS.parse(url.query);
    }
    return url;
  };

  /*
  Adds a URL rule
  */


  Router.prototype.add = function() {
    var creator, defaultParams, handler, parser, pattern, _arg, _i, _ref;
    pattern = arguments[0], _arg = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), handler = arguments[_i++];
    defaultParams = _arg[0];
    defaultParams || (defaultParams = {});
    _ref = this.processPattern(pattern, defaultParams), parser = _ref[0], creator = _ref[1];
    this.rules.push([parser, creator, handler]);
    return this;
  };

  /*
  Process a pattern and returns a url parser and a url creator
  */


  Router.prototype.processPattern = function(pattern, defaultParams) {
    var creator, names, parser, patterns, re, _ref;
    _ref = this.extractPatternReferences(pattern), re = _ref[0], patterns = _ref[1], names = _ref[2];
    parser = this.urlParser(re, names, defaultParams);
    creator = this.urlCreator(patterns, defaultParams);
    return [parser, creator];
  };

  /*
  Returns a function that can parse URLs that match the given regex
  */


  Router.prototype.urlParser = function(re, names, defaultParams) {
    return function(url) {
      var i, matches, name, params, value, _i, _len;
      matches = re.exec(url.pathname);
      if (matches == null) {
        return false;
      }
      params = url.query;
      for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
        name = names[i];
        params[name] = matches[i + 1];
      }
      if (defaultParams != null) {
        for (name in defaultParams) {
          value = defaultParams[name];
          params[name] || (params[name] = value);
        }
      }
      if (url.hash) {
        params['#'] = url.hash.slice(1);
      }
      return params;
    };
  };

  /*
  Returns a function that can create URLs for the given patterns
  */


  Router.prototype.urlCreator = function(patterns, defaultParams) {
    var matchers, name, part, parts, pattern, _i, _len;
    parts = [];
    matchers = {};
    for (_i = 0, _len = patterns.length; _i < _len; _i++) {
      part = patterns[_i];
      if (!Array.isArray(part)) {
        parts.push(part);
        continue;
      }
      name = part[0], pattern = part[1];
      parts.push([name]);
      matchers[name] = new RegExp("^" + pattern + "$");
    }
    return function(options) {
      var copied, pathParts, url, value, _j, _len1;
      if (options == null) {
        options = {};
      }
      pathParts = [];
      copied = [];
      for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
        part = parts[_j];
        if (Array.isArray(part)) {
          name = part[0];
          if (options[name] != null) {
            if (!matchers[name].test(String(options[name]))) {
              return false;
            }
            pathParts.push(options[name]);
            copied.push(name);
          } else if ((defaultParams != null ? defaultParams[name] : void 0) != null) {
            pathParts.push(defaultParams[name]);
          } else {
            return false;
          }
        } else {
          pathParts.push(part);
        }
      }
      url = {
        pathname: "/" + (pathParts.join('')),
        query: {},
        toString: function() {
          return stringifyURL(this);
        }
      };
      if (options['#'] != null) {
        url.hash = "#" + options['#'];
      }
      for (name in options) {
        value = options[name];
        if (!(name === '#' || ~copied.indexOf(name))) {
          url.query[name] = value;
        }
      }
      return url;
    };
  };

  /*
  Extract the pattern references and return an array
  containing a regex and a list of reference names
  */


  Router.prototype.extractPatternReferences = function(pattern) {
    var escaper, matches, name, names, parts, patterns, prefix, referencePattern, regexPart, suffix;
    if (pattern.charAt(0) === '/') {
      pattern = pattern.slice(1);
    }
    if (pattern.charAt(pattern.length - 1) === '/') {
      pattern = pattern.slice(0, pattern.length - 1);
    }
    referencePattern = /([^<]+)?<(\w+)(:([^>]+))?>([^<]+)?/g;
    escaper = /[-[\]{}()*+?.,\\^$|#\s]/g;
    parts = [];
    patterns = [];
    names = [];
    while ((matches = referencePattern.exec(pattern)) != null) {
      if (matches[1] != null) {
        prefix = matches[1].replace(escaper, "\\$&");
      } else {
        prefix = '';
      }
      name = matches[2];
      if (matches[4] != null) {
        if (!/^\((.*)\)$/.test(matches[4])) {
          matches[4] = "(" + matches[4] + ")";
        }
      } else {
        matches[4] = '(\\w+)';
      }
      regexPart = matches[4];
      if (matches[5] != null) {
        suffix = matches[5].replace(escaper, "\\$&");
      } else {
        suffix = '';
      }
      names.push(name);
      parts.push(prefix, regexPart, suffix);
      patterns.push(prefix, [name, regexPart], suffix);
    }
    if (names.length === 0) {
      parts.push(pattern.replace(escaper, "\\$&"));
    }
    return [new RegExp("^\/" + (parts.join(''))), patterns, names];
  };

  return Router;

})();
